Q.1
Now that we have the parent selector, let's use it to add a :hover state to .notice a with a color: #313131; property. While we're at it, we should nest a inside of .notice properly.
Ans

.notice {
  background: yellow;
  border: 5px solid #000;
  padding: 20px;
   a {
    color: #222;
    &:hover{
    color: #313131;
    }
  }

}
.notice a {
  color: #222;
  &:hover{
    color: #313131;
    }
}

Q.2
We've found a change to .surveyor further on in our stylesheet - it needs a bit more padding inside .factory containers. We'd be better off nesting this change inside .surveyor.
Ans.

.surveyor {
  border: 1px solid #ccc;
  padding: 20px;

.factory & {
  padding: 30px;
 }
}

Q3.
Someone was a bit overzealous in their nesting: the a styles should apply to any anchors in .notice rather than anchors in .notice.alert. Adjust the nesting below to compensate.

Ans.

.notice {
  background: yellow;
  border: 5px solid #000;
  padding: 20px;
   a {
      color: #222;
      &:hover {
        color: #313131;
      }
    }
  &.alert {
    background: red;
    box-shadow: 0 0 10px red;

  }
}

Q4.
The color hex value #797979 has been popping up quite a bit throughout our stylesheet. Let's store the color in a variable and replace all instances of it with that variable.

Ans:
$one: #797979;

.surveyor {

  border: 1px solid $one;
  padding: 20px;
}
.surveyor h2 {
  color: $one;
  font-size: 18px;
}

.notice {
  background: yellow;
  border: 5px solid $one;
  padding: 10px;
}

Q5.
A coworker has been asking to see our modals partial for another project. Before we hand it over, let's clean up the repeated padding declarations to use a variable. To keep it modular, that variable definition should ensure it doesn't override a variable of the same name set elsewhere.
Ans:

$pad: 10px !default;
.modal {
  background: #fff;
  box-shadow: 0 2px 5px rgba(0,0,0,0.3);
  padding: $pad;
}
.modal-title {
  border-bottom: 1px solid #ccc;
  font-size: 24px;
  padding: $pad;
}
.modal-action {
  background: purple;
  display: block;
  padding: $pad;
}

Q6.
A last-minute change from the designer just came through: the padding value for the various modal components should be 20px 10px 15px instead of 10px. Knowing we can have lists stored in variables, alter $modal-padding to reflect this revision.

Ans
$modal-padding: 20px 10px 15px !default;

.modal {
  background: #fff;
  box-shadow: 0 2px 5px rgba(0,0,0,0.3);
  padding: $modal-padding;
}
.modal-title {
  border-bottom: 1px solid #ccc;
  font-size: 24px;
  padding: $modal-padding;
}
.modal-action {
  background: purple;
  display: block;
  padding: $modal-padding;
}

Q7.
Our $font-base variable comes in handy when setting the font family in body, but we're getting an error when trying to use it elsewhere. Refactor the styles below so that $font-base is usable throughout.

Ans
 $font-base: 'Helvetica Neue', Helvetica, Arial, sans-serif;
body {
  background: #fff;
  font: normal 16px/1.5 $font-base;
  margin: 0;
  padding: 0;
}
.blueprint {
  font: bold 24px/1.3 Georgia, serif;
  text-align: center;
  span {
    font-family: $font-base;
  }
}

Q8.
We'd like to add a simple way to set which side borders appear on. Create a variable with the current value (left) and interpolate that value into each border property occurance.
Ans.
$variable-name: left;
.girder {
  border-#{$variable-name}: 4px solid #ccc;
  h2 {
    font-size: 24px;
  }
}
.notice {
  border-#{$variable-name}: 8px solid #797979;
  a {
    color: #222;
  }
}

Q9.
We'd like to add a simple way to set which side borders appear on. Create a variable with the current value (left) and interpolate that value into each border property occurance.
Ans.
$variable-name: left;

.girder {
  border-#{$variable-name}: 4px solid #ccc;
  h2 {
    font-size: 24px;
  }
}
.notice {
  border-#{$variable-name}: 8px solid #797979;
  a {
    color: #222;
  }
}



Q10.
We've identified a set of properties that commonly appear in our stylesheet (sometimes with minor tweaks). Let's streamline the process of using these values by adding the commented lines to a mixin called assemble, then calling that mixin in .factory and .highrise.

Ans
@mixin assemble{
  background: #fff;
 border: 1px solid #ccc;
 padding: 10px;
}

.factory {
 @include assemble;
}
.highrise {
@include assemble;
}

Q11.
That's a good start, but we need the ability to change the background color. Alter the mixin to take an argument called $bg, which should then be set as the value of the background property. Pass #fff in for .factory and #797979 in for .highrise.

Ans.

@mixin assemble ($bg) {
  background: ($bg);
  border: 1px solid #ccc;
  padding: 10px;
}

.factory {
  @include assemble(#fff);
}
.highrise {
  @include assemble(#797979);
}

Q12.
The background color for declarations using assemble will most often be #fff. Add a default value to the $bg argument to reflect this discovery. Note: once the default value is set, remember to update your .factory @include.

Ans.
@mixin assemble($bg: #fff) {
  background: $bg;
  border: 1px solid #ccc;
  padding: 10px;
}

.factory {
  @include assemble;
}
.highrise {
  @include assemble(#797979);
}

Q13.
Some elements also need a nonstandard amount of padding. Create a second argument, $pad, with a default value of 10px. .factory uses the default value, but .highrise should have 20px of padding on all sides.
Ans.
@mixin assemble($bg: #fff, $pad: 10px){
  background: $bg;
  padding: $pad;
  border: 1px solid #ccc;
  padding: 10px;
}

.factory {
  @include assemble;
}
.highrise {
  @include assemble(#797979, 20px);
}

Q14.
Given the number of people collaborating on this stylesheet, we should make the mixin call as clear as possible. Add $bg: and $pad: to the .highrise @include arguments, creating keyword arguments.

Ans.
@mixin assemble($bg: #fff, $pad: 10px) {
  background: $bg;
  padding: $pad;
  border: 1px solid #ccc;
  padding: $pad;
}

.factory {
  @include assemble;
}
.highrise {
  @include assemble($bg: #797979, $pad:20px);
}

Q15.
A change request just came in: the border should only apply to one side of these elements. Add a required argument $side to the mixin and interpolate that value to the border property (passing left as $side should create border-left: 1px solid #ccc, for instance). .factory borders should be on the left side, .highrise borders on the right. As a reminder, arguments without default values need to come before arguments with default values.

Ans.
@mixin assemble($side, $bg: #fff, $pad: 10px) {
  background: $bg;
  border-#{$side}: 1px solid #ccc;
  border: 1px solid #ccc;
  padding: $pad;
}

.factory {
  @include assemble ($side: left);
}
.highrise {
  @include assemble($side: right, $bg: #797979, $pad: 20px);
}

Q16.
We're attempting to pass a comma-separated box-shadow value into our mixin as an argument, but we keep getting an error about the number of arguments. Alter $shadow to be a variable argument and accept the value below.

@mixin modal($shadow...) {
  box-shadow: $shadow;
  border: 1px solid #ccc;
}

.modal {
  @include modal(inset 0 0 5px #000, 0 2px 5px #000);
}

Q17.
It looks like .blueprint and .surveyor have a number of matching properties. Add an @extend to .surveyor to make this section more efficient.

Ans.
.blueprint{
  background: blue;
  border-radius: 5px;
  margin-bottom: 15px;
  padding: 10px;
}
.surveyor {
  @extend .blueprint;
  color: #fff;

}

Q18.
The developers are using .notice in some places of the application, .error in others, and are unable to only use one or the other. Extend the .notice styles into an .error declaration.

Ans.
.notice {
  background: yellow;
  border: 5px solid #000;
  padding: 20px;
  &.alert {
    background: red;
    box-shadow: 0 0 10px red;
  }
  a {
    color: #222;
    &:hover {
      color: #313131;
    }
  }
}
.error {
  @extend .notice;
}

Q19.
Some of the CSS copied over originally contains already-combined selectors. Refactor the segment below to make use of extend on .socket instead, in case we need to add elements later.

Ans.
.socket,{
  border-radius: 50%;
  padding: 15px;
  width: 30px;
}
.wrench {
  @extend .socket;
  width: 100px;
}
.bolt {
   @extend .socket;
  padding: 14px;
}

Q19.
.group (commonly referred to as clearfix) is used throughout our application for clearing floats. To keep use of this relegated to our styles rather than allowing .group to be added as a class, convert .group over to a placeholder selector and update the extend inside .factory.

Ans.%group {
  zoom: 1;
  &:before,
  &:after {
    content: '';
    display: table;
  }
  &:after {
    clear: both;
  }
}

.factory {
  @extend %group;
  background: #fff;
}

Q.20
Whoops - we've discovered an alteration to .blueprint later in our stylesheet, and extending .blueprint with .surveyor is creating extra selectors in .factory that aren't needed. Create a placeholder selector called container to hold the shared properties and extend it with .blueprint and .surveyor to remove the extra .factory .surveyor selector.

Ans.
%container {
  background: blue;
  border-radius: 5px;
  margin-bottom: 15px;
  padding: 10px;
}
.blueprint {
  @extend %container;
}
.surveyor {
   @extend %container;
   color: #fff;
}

.factory {
  background: #fff;
 .blueprint {
    margin-bottom: 20px;
  }
}

Q21.
We need to find the height of video containers given a width and a 16:9 aspect ratio. To avoid doing the math manually each time, create a function called aspect that takes a $width argument and returns the commented-out formula. Then, use it to set the height on .intro given a width of 500px.

Ans.
// $width * 9 / 16
@function aspect($width){
		@return  $width * 9 / 16
  }

.intro {
  background: #000;
  width: 500px;
  height: aspect(500px);
}

Q22.
A number stored in $size is being used to set the font size for our .switch. Based on $size, create a conditional statement with @if inside .switch: if $size is less than or equal to 16px, font-family: Arial, sans-serif; is output. Otherwise, font-family: Helvetica, sans-serif; is output.

Ans.
$size: 18px;

.switch {
  font-size: $size;
  @if $size <= 16px {
    font-family: Arial, sans-serif;
    }@else{
    font-family: Helvetica, sans-serif;
    }
}

Q23.
On the same conditional, use @else if to add a condition between the existing @if and @else: if $size is less than or equal to 24px, font-family: Georgia, serif; is output.

Ans.
$size: 18px;

  .switch {
    font-size: $size;
    @if $size <= 16px {
      font-family: Arial, sans-serif;
    } @else if $size <= 24px {
      font-family: Georgia, serif;
    } @else {
      font-family: Helvetica, sans-serif;
    }
  }


Q24.
This @if directive could be useful outside .switch - let's expand the scope. Move everything inside of .switch to a mixin called family that takes an argument of $size. Remove the existing $size: 18px; line, then call the mixin from within .switch, passing 18px as an argument.

Ans.
@mixin family ($size) {
  font-size: $size;
  @if $size <= 16px {
    font-family: Arial, sans-serif;
  } @else if $size <= 24px {
    font-family: Georgia, serif;
  } @else {
    font-family: Helvetica, sans-serif;
  }
}
.switch {
   @include family(18px);
  }

Q25.
Someone left us a to-do above this segment - we can clean it up for future expansion by generating the selectors and background with @each. Start by creating a list variable named $tools to store socket, wrench, and bolt.
// TODO: simplify with @each

.tool-socket {
  background: url('socket.png') no-repeat;
}
.tool-wrench {
  background: url('wrench.png') no-repeat;
}
.tool-bolt {
  background: url('bolt.png') no-repeat;
}

Ans.
// TODO: simplify with @each
$tools: socket wrench bolt;
@each $tool in $tools {
  .tool-#{$tool} {
     background: url('#{$tool}.png') no-repeat;
    }
}


Q26.
Technically, it works - but this @for with a nested @if is more complicated than necessary to target odd numbers from 1 to 7. Remove the @if statement and refactor the @for using @while instead to achieve the same result. Note: if you aren't familiar with the % operator, don't worry - it's covered in the next level.

@for $i from 1 through 7 {
  @if $i % 2 != 0 {
    .row-#{$i} {
      background: #ccc;
      height: $i * 10px;
    }
  }
}


Ans.
$i: 1;

@while $i <= 7 {
  .row-#{$i} {
    background: #ccc;
    height: $i * 10px;
  }
  $i: $i + 2;
}

Q27.
To ensure consistent spacing between columns, our stylesheet has a reusable $gutter variable. Subtract the width values in .factory and .highrise by $gutter to account for the margin.

Ans.
$gutter: 20px;

.factory {
  background: #fff;
  margin-right: $gutter;
  width: 600px - $gutter;
}
.highrise {
  background: #797979;
  margin-right: $gutter;
  width: 300px - $gutter;
}

Q28.
Your coworker has been attempting to set the font size of span elements inside .sign to half the .sign font size, without success. Knowing what you do about triggering division, utilize parentheses to fix the problem.
.sign {
  font-size: 3.75em;
  font-weight: bold;
  padding: 20px 40px;
  span {
    font-size: 3.75em / 2;
  }
}
Ans.
.sign {
  font-size: 3.75em;
  font-weight: bold;
  padding: 20px 40px;
  span {
    font-size: (3.75em / 2);
  }
}

Q29.
3.75em has been recurring throughout our stylesheet, so let's move it to a variable and use that variable where possible. Remember: utilizing a variable also triggers division, which removes the need for our parentheses.

Ans.
$default-font-size: 3.75em;
.sign {
  font-size: $default-font-size;
  font-weight: bold;
  padding: 20px 40px;
  span {
    font-size: $default-font-size / 2;
  }
}


Q30.Our @if directive performs a bit of string concatenation, but we'd prefer if the output value had quotes around it. Tweak the directive to ensure this is the case.

Ans.
$theme: modern;
$font: 'serif';

@if $theme == modern {
  $font: 'sans-' + $font;
}

.sign {
  font-family: $font;
}

Q31.
On reflection, it'd be nice to have a cleaner font size to work with after performing arithmetic inside our span. Use the appropriate built-in function to round the span's font size to the nearest whole number.

Ans.
$size: 3.75em;

.sign {
  font-size: 3.75em;
  font-weight: bold;
  padding: 20px 40px;
  span {
    font-size: round($size / 2);
  }
}

Q32.
Our .factory and .highrise declarations are lacking responsiveness: using the target / context formula, the given $context variable, and percentage(), give each declaration a fluid width. No need to refactor this into a separate function, just add your percentage() calls within .factory and .highrise.

Ans.
$context: 960px;

.factory {
  background: #fff;
  width: percentage(600px / $context);
}
.highrise {
  background: #797979;
  width: percentage(300px / $context);
}

Q33.
We've stored a hex color value in $color-base, but the rgb equivalent (121,121,121) is being used in .modal. Use the shorthand version of rgba() to make use of the already-available $color-base value.

Ans.
$color-base: #797979;

.modal {
  background: rgba($color-base,0.75);
  border: 1px solid $color-base;
  padding: 20px;
}

Q34.
Anchor elements are currently missing a hover state - add one via nesting which sets a color 15% lighter than $color-link.
$color-link: #3097b4;

a {
  color: $color-link;
  text-decoration: underline;
}


Ans.$color-link: #3097b4;

a {
  color: $color-link;
  text-decoration: underline;
  &:hover {
     color: lighten($color-link, 15%);
  }
}

Q35.
Our newly-added hover state isn't bad, but we'd like to up the intensity a bit. Keeping the lighter value, increase the saturation by 20%. Note: look to the :active state to see an example of nested color functions.
$color-link: #3097b4;

a {
  color: $color-link;
  text-decoration: underline;
  &:hover {
    color: lighten($color-link, 15%);
  }
  &:active {
    color: desaturate(darken($color-link, 15%), 25%);
  }
}

Ans.

$color-link: #3097b4;

a {
  color: $color-link;
  text-decoration: underline;
  &:hover {
    color: saturate(lighten($color-link, 15%), 20%);

  }
  &:active {
    color: desaturate(darken($color-link, 15%), 25%);

  }
}

Q36.
Unfortunately, our hover state just isn't obvious enough. Remove the saturate() and lighten() additions, and use a color function to invert the value.
$color-link: #3097b4;

a {
  color: $color-link;
  text-decoration: underline;
  &:hover {
    color: saturate(lighten($color-link, 15%), 20%);
  }
  &:active {
    color: desaturate(darken($color-link, 15%), 25%);
  }
}


Ans.
$color-link: #3097b4;

a {
  color: $color-link;
  text-decoration: underline;
  &:hover {
    color: invert($color-link);
  }

  &:active {
    color: desaturate(darken($color-link, 15%), 25%);
  }
}
Q37.
Our stylesheet contains a responsive breakpoint with some alterations to .factory. Let's clean up the media query a bit by nesting it inside .factory.
    .factory {
      width: 100%;
    }
    @media (min-width: 960px) {
      .factory {
        width: percentage(600px / 960px);
      }
    }
Ans.
    .factory {
      width: 100%;

    @media (min-width: 960px) {

        width: percentage(600px / 960px);

    }
    }
Q38.
Media query handling has now been moved to a respond-to mixin, which has a fixed breakpoint for when desktop is passed as an argument. Use @else if to add a second condition that checks for an argument of tablet. tablet should output a media query with a min-width of 768px containing the @content block.

@mixin respond-to($media) {
  @if $media == desktop {
    @media (min-width: 960px) {
      @content;
    }
  }
}

.factory {
  width: 100%;
  @include respond-to(desktop) {
    width: percentage(600px / 960px);
  }
  @include respond-to(tablet) {
    width: 50%;
  }
}

Ans.
@mixin respond-to($media) {
  @if $media == desktop {
    @media (min-width: 960px) {
      @content;
    }
  }@else if $media == tablet {
  @media (min-width: 768px) {
      @content;
  }
}
}
.factory {
  width: 100%;
  @include respond-to(desktop) {
    width: percentage(600px / 960px);
  }
  @include respond-to(tablet) {
    width: 50%;
  }
}

Q39.
Let's make our respond-to more flexible by allowing it to accept query values rather than fixed breakpoints. Rewrite the mixin to output a media query with a min-width of the $query argument, which contains the @content block.
@mixin respond-to($query) {

}

.factory {
  width: 100%;
  @include respond-to(960px) {
    width: percentage(600px / 960px);
  }
  @include respond-to(768px) {
    width: 50%;
  }
}

Ans.
@mixin respond-to($query) {
@media (min-width: $query) {
   @content;
  }
}

.factory {
  width: 100%;
  @include respond-to(960px) {
    width: percentage(600px / 960px);
  }
  @include respond-to(768px) {
    width: 50%;
  }
}

Q40.
We should further expand our mixin to allow for queries beyond min-width. Add $type as the first argument to respond-to, which will be used in place of min-width when passed in.
@mixin respond-to($query) {
  @media (min-width: $query) {
    @content;
  }
}

.factory {
  width: 100%;
  @include respond-to(min-width, 960px) {
    width: percentage(600px / 960px);
  }
  @include respond-to(max-width, 768px) {
    width: 50%;
  }
}

Ans.
@mixin respond-to($type, $query) {
  @media ($type: $query) {
    @content;
  }
}

.factory {
  width: 100%;
  @include respond-to(min-width, 960px) {
    width: percentage(600px / 960px);
  }
  @include respond-to(max-width, 768px) {
    width: 50%;
  }
}
Q41.

Ans.
We've noticed that our most common call to respond-to passes in min-width for $type and 960px for $query: create default values out of each so that our simplified @include works correctly.

Q42.

Ans.

Q43.

Ans.

Q44.

Ans.

Q45.

Ans.

Q46.

Ans.

Q47.

Ans.


Q48.

Ans.

Q49.

Ans.

Q50.

Ans.


Q50.

Ans.


Q50.

Ans.


Q50.

Ans.


Q50.

Ans.


Q50.

Ans.


Q50.

Ans.


Q50.

Ans.


Q50.

Ans.


Q50.

Ans.


Q50.

Ans.
